{
  "sessionId": "7004b6e6-a9e8-4978-996a-4f0ea02eea60",
  "projectHash": "c18d7838341f26b2faf404a32bd7a26945c68d2a55988ef45bd0bd91a1777dc6",
  "startTime": "2026-01-06T21:48:43.086Z",
  "lastUpdated": "2026-01-06T21:53:40.100Z",
  "messages": [
    {
      "id": "6265ae81-bc9c-4d40-8b61-cabcac4b5161",
      "timestamp": "2026-01-06T21:48:43.086Z",
      "type": "error",
      "content": "Automatic update failed. Please try updating manually"
    },
    {
      "id": "dc28202c-2eea-43b0-898c-6368749824d0",
      "timestamp": "2026-01-06T21:50:11.724Z",
      "type": "user",
      "content": "could you transform @bmad+gemini_cli.txt to a more structued and agreable to read text in md format but dont change anything in the content\n--- Content from referenced files ---\nContent from @bmad+gemini_cli.txt:\nSidebar menu\nSearch\nWrite\nNotifications\n\nAmine Aliane\nDipping a toe cautiously in to vibe coding on the CLI with Gemini, Go and the BMAD Method\nSean Condon\nSean Condon\n9 min read\n·\nSep 5, 2025\n--\n\n\n\n\n\n\n\nMany of us engineers like to take things apart to understand what makes them tick (I’ve even learnt over many years how to put them back together too, with a minimum of parts left over!).\n\nSo when I heard the hype about vibe coding and how we could be replaced by it in a short number of years, my immediate reaction was to dive in and see how it works and if I could get it to do something useful.\n\nWhile there are many tools and techniques are cropping up to support this, such as Cursor, Replit, Lovable and Google Jules, I wanted something more fundamental and granular so that I could see the dependencies between the parts in terms more familiar. As an experienced developer I wanted to see some rigor in the process and how it deals with the many pitfalls in software development.\n\nFor some people, Vibe Coding and caution are mutually exclusive terms, and some might say what’s I’m doing here is more Spec driven development with AI — but arguing about semantics is outside of the scope of this article.\n\nThe BMAD Method\nA colleague suggested looking at the BMAD Method. Named after its originator, Brian Madison, this is basically an exercise in Prompt Engineering that embeds the Software Development Lifecycle in to a series of markdown documents, that contain strongly opinionated System Prompts that can be used with an LLM. BMAD has cleverly constructed personas within these prompts so that there are system prompts related to Analyst, Product Owner, Project Manager, Architect, Scrum Master, Developer and QA.\n\nThe task — create a tool\nRecently I’ve been looking in to Knowledge Graphs with Neo4j and specifically how they can be used to drive Context Engineering in an AI driven SRE (Site Reliability Engineering) environment. As the first step of this I wanted to create a tool that could extract relationships from Helm Charts and put them in to a Knowledge Graph.\n\nThis was vibe coding’s and BMAD method’s time to shine — could it implement this as a CLI tool in the Go programming language? While this small self-contained tool has no UI and no external service it still has enough complexity to test vibe coding’s ability to do something useful.\n\nThe prompt\nAs input, I came up with this initial prompt:\n\n*plan I want to develop a new project from scratch. I want to design a service that will allow me to examine a helm chart and convert it in to cypher query commands so that is can be loaded in to Neo4j graph database. The service should accept the name of the helm chart and use the “helm template” command to produce a manifest as an intermediate step. The through this manifest “kind” in the helm chart should be taken as a node type and each instance of this kind should be treated as a node (identified by label.name and label.namespace).\n\nUsing the BMAD Method\nBMAD breaks up the tasks in to Planning and Execute — the former to create the document structure like the PRD and the architecture documents (which can be run on lower cost LLM models on a conventional Web UI) and the latter to generate the code (run on more code generation oriented LLM models in an IDE). The BMAD system prompts are clever enough to include checkpoints so that previous steps are not missed.\n\nUsing Google Gemini CLI\nI have recently become a fan of Google’s Gemini CLI and I wanted to see if I could use this to drive this vibe coding effort. I’m not inclined to switch between the latest greatest thing in LLMs and tools — I’d much prefer to choose one good one and go deep with it, as this I believe reflects what developers in a professional environment would have to do. Google Gemini 2.5 -flash and -pro models seem to be up there with the best of them, and so I wanted to stick with this for my exercise. There are many ways to consume Gemini — I went with Google AI Studio where I got an API key and linked it to a Google Cloud Platform Project.\n\nFortunately BMAD has crafted a strong Gemini related System Prompt in a .gemini/bmad-method/GEMINI.md that refers across to his other markdown files in .bmad-core folder. The npx installer for BMAD gives an option to install this, such that Gemini will pick it up properly. In essence the npx installer is not that complex and it’s only purpose is choose which files to download to the correct place.\n\nStarting the process\nSo with all these ingredients in place it was time to get started. I created a new repo at https://github.com/SRE-Spaghetti/helmgraph on Github and then cloned it to my machine. I changed in to this directory in the terminal and there I ran npx bmad-method install and chose the Gemini CLI.\n\nPress enter or click to view image in full size\nScreenshot of installing the BMAD method\nThen I ran the gemini --model gemini-2.5-flash command to start the Gemini CLI and running *help shows that the BMAD Orchestrator is ready to go. Running this *help command sends the BMAD markdown files over the Gemini API and so consumes some input tokens.\n\nPress enter or click to view image in full size\nStarting Gemini CLI with BMAD\nThere are many different ways to start the process, and Gemini will make big assumptions that will easily steer you in the wrong direction. For instance in one case I started with *workflow greenfield-service and gave it the name helmgraph and from just that one word it created a complete project brief!\n\nPress enter or click to view image in full size\nChoosing the Greenfield-Service workflow in the BMAD Method on Gemini\nI found that giving it a *plan (with the prompt from above) beforehand produced much better results. You can always reset your context by pressing Esc, and you can track in another terminal window what have been created or changed with the git status command.\n\nCreating the project brief\nAfter entering the plan, it churns around a lot and eventually proposes a project type — I chose greenfield-service and went straight to the project brief. This where we get to talk to “Mary — the business analyst” persona and we can go interactive or go wild. The interactive option provides opportunity to interject with more details — but in my case I accepted the defaults all the way through and it eventually created docs/brief.md.\n\nBecome a member\nOnce saved, it automatically jumps on to “John the Project Manager” who wants to create the PRD straight away. I find this is a good place to stop (press Esc or get out of Gemini altogether) and review and edit the brief manually and commit it to Git. This gives you a baseline that you can review with others, and edit manually. Remember you’re in control, it’s only a document and you know better what it should do than AI does.\n\nIn my case I edited the brief at this stage to say I wanted it developed in Go and details about the command line options (I should have said this in the plan originally). By stopping and breaking up the task in to discrete segments that are individually understandable, we’re following Gall’s law on how to construct a complex system — something that free-flowing vibe coding tends to ignore.\n\nCost analysis\nExiting out of Gemini at this stage gives you a summary of the costs incurred:\n\nInput Tokens: 2,724,275\nOutput Tokens 32,406\nSavings Highlight: 2,248,764 (82.5%) of input tokens were served from the cache, reducing costs.\nThe costs will vary over time, but as a guide in Q3 2025 the costs on the paid tier of gemini-2.5-flash were:\n\ninput tokens at $0.30 per 1 million and\noutput tokens at $2.50 per 1 million.\nCompleting the Planning stage\nAfter reviewing the Product Brief you can restart Gemini and jump back into the process again with *agent pm and *create-prd. If it can’t find the product brief you can just tell it where the file is with the @ symbol. It will generate a list of epics and ultimately a docs/prd.md. Again you should stop the process here, commit and review it properly.\n\nThe Planning process continues with the *agent architect who creates docs/architecture.md, and finally BMAD method required that these documents must be sharded, so that the individual Epics are extracted to separate markdown documents. Again these should be checked in to Git and reviewed.\n\nMoving to the Execution stage\nThis is where BMAD suggests to move over to the more advanced model for the Scrum Master (SM) and Developer personas. Quitting Gemini and starting it again will allow choosing the model: gemini --model gemini-2.5-pro.\n\nThis is where the costs go up:\n\n$1.25/million up to 200k input tokens and $2.50 thereafter and\n$10/million up to 200k output tokens and $15 thereafter.\nThe Scrum Master and Developer\nThe SM breaks the epics out in to stories markdown files. Again these should be checked in to Git and reviewed.\n\nThe Developer will iterate through these stories one by one, initializing a Go module and creating a cmd/helmgraph/main.go file. It roughly created a Go file or two per story and a unit test.\n\nI found that sometimes that Gemini running go test … will fail and it will try to resolve this in increasingly wacky ways. I found it’s better to stop the process (with Esc) and run the go test ./… myself to see what the problem was. Generally the problem was not with the test at all, but some import missing in main.go. I found it was useful to open the code in an IDE at the same time to see the details and run the tests.\n\nStopping the process after each story is a good practice as it allows you to check-in the created file and review it. Resuming the process works well, recognizing the steps you have already taken. If you don’t like an implementation of a story just throw it away and run the step again. I think these kind of best practices could easily be added to the BMAD system prompts — a future project…\n\nUser acceptance\nWhen the stories are completed, the code has to be tested in the real world, and a few edits were necessary, but even these were easily handled through Gemini CLI or Gemini Code Assist inside the IDE. For instance I used Code Assist to add the enhanced YAML parsing here and the enhanced error handling here. In the end the program ran very well and created proper syntax for Neo4j Cypher commands — even creating schema statements to constrain the Nodes.\n\ngo run ./cmd/helmgraph/main.go -c ~/git/SRE-Spaghetti/microservices-demo/helm-chart -r foobar\n\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:ServiceAccount) REQUIRE (n.name, n.namespace) IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:Service) REQUIRE (n.name, n.namespace) IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:Deployment) REQUIRE (n.name, n.namespace) IS UNIQUE;\nMERGE (:ServiceAccount {name: 'adservice', namespace: 'default', kind: 'ServiceAccount'});\nMERGE (:ServiceAccount {name: 'cartservice', namespace: 'default', kind: 'ServiceAccount'});\n…\nMERGE (:Service {name: 'adservice', namespace: 'default', kind: 'Service'});\nMERGE (:Service {name: 'cartservice', namespace: 'default', kind: 'Service'});\n…\nMERGE (:Deployment {name: 'adservice', namespace: 'default', kind: 'Deployment'});\nMERGE (:Deployment {name: 'cartservice', namespace: 'default', kind: 'Deployment'});\n…\nMATCH (a:Service {name: 'adservice'}), (b:Deployment {name: 'adservice'}) MERGE (a)-[:SELECTS]->(b);\nMATCH (a:Service {name: 'cartservice'}), (b:Deployment {name: 'cartservice'}) MERGE (a)-[:SELECTS]->(b);\n…\nConclusion & Takeaways\nOverall I was happy with the vibe coding experience and that I could do it on my own terms. Technical knowledge is still very important to get a good outcome, but I think there is a huge time saving to be had here. The whole process took about half a day (including experimentation time) and I racked up costs of about €20 on tokens.\n\nI did run in to limits almost straight away on the free tier of Gemini API, so I enabled billing for my GCP project to allow more tokens be billed on demand. Having spent €20 in just one day on Gemini though makes me think I should go for Google AI Pro on Google One instead at €22/month.\n\nYou could argue the costs involved don’t justify the end result, but here I’m just touching the tip of the iceberg. I think there’s a higher cost in the long term to not be educated and proficient in these tools. The process has given me a lot of confidence in the tools, and I see a pretty strong future for vibe coding.\n\nGemini\nGemini Cli\nVibe Coding\nGolang\nSre\n--\n\n\n\n\n\nSean Condon\nWritten by Sean Condon\n10 followers\n·\n14 following\nNo responses yet\nHelp\n\nStatus\n\nAbout\n\nCareers\n\nPress\n\nBlog\n\nPrivacy\n\nRules\n\nTerms\n\nText to speech\n--- End of content ---"
    },
    {
      "id": "50dd355e-e90b-4a78-859e-900e4df0dec6",
      "timestamp": "2026-01-06T21:51:01.343Z",
      "type": "gemini",
      "content": "I will read the content of `bmad+gemini_cli.txt` and then format it into a structured Markdown file.",
      "thoughts": [
        {
          "subject": "Refining Markdown Generation",
          "description": "I'm currently focused on structuring the content from `bmad+gemini_cli.txt` into a clean Markdown format. The goal is complete preservation of the original text, aiming for maximum readability. I'm exploring various Markdown elements to achieve optimal presentation.",
          "timestamp": "2026-01-06T21:50:57.920Z"
        },
        {
          "subject": "Considering File Transformation Strategy",
          "description": "I'm now contemplating how to effectively handle the transformation to Markdown. I'll read `bmad+gemini_cli.txt` to confirm its content. Then, I plan to format it into Markdown. Finally, I will write the result to a new file, `bmad+gemini_cli.md`, adhering to the implied instruction.",
          "timestamp": "2026-01-06T21:51:00.316Z"
        },
        {
          "subject": "Planning Markdown Conversion",
          "description": "I've analyzed the file's structure and content, identifying headers, author information, and sections. My plan is to use Markdown headers for the title and sections, along with lists and code blocks where appropriate, to maintain content accuracy while improving readability. I am ready to implement the content conversion now.",
          "timestamp": "2026-01-06T21:51:01.298Z"
        }
      ],
      "tokens": {
        "input": 19268,
        "output": 46,
        "cached": 0,
        "thoughts": 558,
        "tool": 0,
        "total": 19872
      },
      "model": "gemini-3-flash-preview",
      "toolCalls": [
        {
          "id": "read_file-1767736261335-05157d7e20ff5",
          "name": "read_file",
          "args": {
            "file_path": "bmad+gemini_cli.txt"
          },
          "result": [
            {
              "functionResponse": {
                "id": "read_file-1767736261335-05157d7e20ff5",
                "name": "read_file",
                "response": {
                  "output": "Sidebar menu\nSearch\nWrite\nNotifications\n\nAmine Aliane\nDipping a toe cautiously in to vibe coding on the CLI with Gemini, Go and the BMAD Method\nSean Condon\nSean Condon\n9 min read\n·\nSep 5, 2025\n--\n\n\n\n\n\n\n\nMany of us engineers like to take things apart to understand what makes them tick (I’ve even learnt over many years how to put them back together too, with a minimum of parts left over!).\n\nSo when I heard the hype about vibe coding and how we could be replaced by it in a short number of years, my immediate reaction was to dive in and see how it works and if I could get it to do something useful.\n\nWhile there are many tools and techniques are cropping up to support this, such as Cursor, Replit, Lovable and Google Jules, I wanted something more fundamental and granular so that I could see the dependencies between the parts in terms more familiar. As an experienced developer I wanted to see some rigor in the process and how it deals with the many pitfalls in software development.\n\nFor some people, Vibe Coding and caution are mutually exclusive terms, and some might say what’s I’m doing here is more Spec driven development with AI — but arguing about semantics is outside of the scope of this article.\n\nThe BMAD Method\nA colleague suggested looking at the BMAD Method. Named after its originator, Brian Madison, this is basically an exercise in Prompt Engineering that embeds the Software Development Lifecycle in to a series of markdown documents, that contain strongly opinionated System Prompts that can be used with an LLM. BMAD has cleverly constructed personas within these prompts so that there are system prompts related to Analyst, Product Owner, Project Manager, Architect, Scrum Master, Developer and QA.\n\nThe task — create a tool\nRecently I’ve been looking in to Knowledge Graphs with Neo4j and specifically how they can be used to drive Context Engineering in an AI driven SRE (Site Reliability Engineering) environment. As the first step of this I wanted to create a tool that could extract relationships from Helm Charts and put them in to a Knowledge Graph.\n\nThis was vibe coding’s and BMAD method’s time to shine — could it implement this as a CLI tool in the Go programming language? While this small self-contained tool has no UI and no external service it still has enough complexity to test vibe coding’s ability to do something useful.\n\nThe prompt\nAs input, I came up with this initial prompt:\n\n*plan I want to develop a new project from scratch. I want to design a service that will allow me to examine a helm chart and convert it in to cypher query commands so that is can be loaded in to Neo4j graph database. The service should accept the name of the helm chart and use the “helm template” command to produce a manifest as an intermediate step. The through this manifest “kind” in the helm chart should be taken as a node type and each instance of this kind should be treated as a node (identified by label.name and label.namespace).\n\nUsing the BMAD Method\nBMAD breaks up the tasks in to Planning and Execute — the former to create the document structure like the PRD and the architecture documents (which can be run on lower cost LLM models on a conventional Web UI) and the latter to generate the code (run on more code generation oriented LLM models in an IDE). The BMAD system prompts are clever enough to include checkpoints so that previous steps are not missed.\n\nUsing Google Gemini CLI\nI have recently become a fan of Google’s Gemini CLI and I wanted to see if I could use this to drive this vibe coding effort. I’m not inclined to switch between the latest greatest thing in LLMs and tools — I’d much prefer to choose one good one and go deep with it, as this I believe reflects what developers in a professional environment would have to do. Google Gemini 2.5 -flash and -pro models seem to be up there with the best of them, and so I wanted to stick with this for my exercise. There are many ways to consume Gemini — I went with Google AI Studio where I got an API key and linked it to a Google Cloud Platform Project.\n\nFortunately BMAD has crafted a strong Gemini related System Prompt in a .gemini/bmad-method/GEMINI.md that refers across to his other markdown files in .bmad-core folder. The npx installer for BMAD gives an option to install this, such that Gemini will pick it up properly. In essence the npx installer is not that complex and it’s only purpose is choose which files to download to the correct place.\n\nStarting the process\nSo with all these ingredients in place it was time to get started. I created a new repo at https://github.com/SRE-Spaghetti/helmgraph on Github and then cloned it to my machine. I changed in to this directory in the terminal and there I ran npx bmad-method install and chose the Gemini CLI.\n\nPress enter or click to view image in full size\nScreenshot of installing the BMAD method\nThen I ran the gemini --model gemini-2.5-flash command to start the Gemini CLI and running *help shows that the BMAD Orchestrator is ready to go. Running this *help command sends the BMAD markdown files over the Gemini API and so consumes some input tokens.\n\nPress enter or click to view image in full size\nStarting Gemini CLI with BMAD\nThere are many different ways to start the process, and Gemini will make big assumptions that will easily steer you in the wrong direction. For instance in one case I started with *workflow greenfield-service and gave it the name helmgraph and from just that one word it created a complete project brief!\n\nPress enter or click to view image in full size\nChoosing the Greenfield-Service workflow in the BMAD Method on Gemini\nI found that giving it a *plan (with the prompt from above) beforehand produced much better results. You can always reset your context by pressing Esc, and you can track in another terminal window what have been created or changed with the git status command.\n\nCreating the project brief\nAfter entering the plan, it churns around a lot and eventually proposes a project type — I chose greenfield-service and went straight to the project brief. This where we get to talk to “Mary — the business analyst” persona and we can go interactive or go wild. The interactive option provides opportunity to interject with more details — but in my case I accepted the defaults all the way through and it eventually created docs/brief.md.\n\nBecome a member\nOnce saved, it automatically jumps on to “John the Project Manager” who wants to create the PRD straight away. I find this is a good place to stop (press Esc or get out of Gemini altogether) and review and edit the brief manually and commit it to Git. This gives you a baseline that you can review with others, and edit manually. Remember you’re in control, it’s only a document and you know better what it should do than AI does.\n\nIn my case I edited the brief at this stage to say I wanted it developed in Go and details about the command line options (I should have said this in the plan originally). By stopping and breaking up the task in to discrete segments that are individually understandable, we’re following Gall’s law on how to construct a complex system — something that free-flowing vibe coding tends to ignore.\n\nCost analysis\nExiting out of Gemini at this stage gives you a summary of the costs incurred:\n\nInput Tokens: 2,724,275\nOutput Tokens 32,406\nSavings Highlight: 2,248,764 (82.5%) of input tokens were served from the cache, reducing costs.\nThe costs will vary over time, but as a guide in Q3 2025 the costs on the paid tier of gemini-2.5-flash were:\n\ninput tokens at $0.30 per 1 million and\noutput tokens at $2.50 per 1 million.\nCompleting the Planning stage\nAfter reviewing the Product Brief you can restart Gemini and jump back into the process again with *agent pm and *create-prd. If it can’t find the product brief you can just tell it where the file is with the @ symbol. It will generate a list of epics and ultimately a docs/prd.md. Again you should stop the process here, commit and review it properly.\n\nThe Planning process continues with the *agent architect who creates docs/architecture.md, and finally BMAD method required that these documents must be sharded, so that the individual Epics are extracted to separate markdown documents. Again these should be checked in to Git and reviewed.\n\nMoving to the Execution stage\nThis is where BMAD suggests to move over to the more advanced model for the Scrum Master (SM) and Developer personas. Quitting Gemini and starting it again will allow choosing the model: gemini --model gemini-2.5-pro.\n\nThis is where the costs go up:\n\n$1.25/million up to 200k input tokens and $2.50 thereafter and\n$10/million up to 200k output tokens and $15 thereafter.\nThe Scrum Master and Developer\nThe SM breaks the epics out in to stories markdown files. Again these should be checked in to Git and reviewed.\n\nThe Developer will iterate through these stories one by one, initializing a Go module and creating a cmd/helmgraph/main.go file. It roughly created a Go file or two per story and a unit test.\n\nI found that sometimes that Gemini running go test … will fail and it will try to resolve this in increasingly wacky ways. I found it’s better to stop the process (with Esc) and run the go test ./… myself to see what the problem was. Generally the problem was not with the test at all, but some import missing in main.go. I found it was useful to open the code in an IDE at the same time to see the details and run the tests.\n\nStopping the process after each story is a good practice as it allows you to check-in the created file and review it. Resuming the process works well, recognizing the steps you have already taken. If you don’t like an implementation of a story just throw it away and run the step again. I think these kind of best practices could easily be added to the BMAD system prompts — a future project…\n\nUser acceptance\nWhen the stories are completed, the code has to be tested in the real world, and a few edits were necessary, but even these were easily handled through Gemini CLI or Gemini Code Assist inside the IDE. For instance I used Code Assist to add the enhanced YAML parsing here and the enhanced error handling here. In the end the program ran very well and created proper syntax for Neo4j Cypher commands — even creating schema statements to constrain the Nodes.\n\ngo run ./cmd/helmgraph/main.go -c ~/git/SRE-Spaghetti/microservices-demo/helm-chart -r foobar\n\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:ServiceAccount) REQUIRE (n.name, n.namespace) IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:Service) REQUIRE (n.name, n.namespace) IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:Deployment) REQUIRE (n.name, n.namespace) IS UNIQUE;\nMERGE (:ServiceAccount {name: 'adservice', namespace: 'default', kind: 'ServiceAccount'});\nMERGE (:ServiceAccount {name: 'cartservice', namespace: 'default', kind: 'ServiceAccount'});\n…\nMERGE (:Service {name: 'adservice', namespace: 'default', kind: 'Service'});\nMERGE (:Service {name: 'cartservice', namespace: 'default', kind: 'Service'});\n…\nMERGE (:Deployment {name: 'adservice', namespace: 'default', kind: 'Deployment'});\nMERGE (:Deployment {name: 'cartservice', namespace: 'default', kind: 'Deployment'});\n…\nMATCH (a:Service {name: 'adservice'}), (b:Deployment {name: 'adservice'}) MERGE (a)-[:SELECTS]->(b);\nMATCH (a:Service {name: 'cartservice'}), (b:Deployment {name: 'cartservice'}) MERGE (a)-[:SELECTS]->(b);\n…\nConclusion & Takeaways\nOverall I was happy with the vibe coding experience and that I could do it on my own terms. Technical knowledge is still very important to get a good outcome, but I think there is a huge time saving to be had here. The whole process took about half a day (including experimentation time) and I racked up costs of about €20 on tokens.\n\nI did run in to limits almost straight away on the free tier of Gemini API, so I enabled billing for my GCP project to allow more tokens be billed on demand. Having spent €20 in just one day on Gemini though makes me think I should go for Google AI Pro on Google One instead at €22/month.\n\nYou could argue the costs involved don’t justify the end result, but here I’m just touching the tip of the iceberg. I think there’s a higher cost in the long term to not be educated and proficient in these tools. The process has given me a lot of confidence in the tools, and I see a pretty strong future for vibe coding.\n\nGemini\nGemini Cli\nVibe Coding\nGolang\nSre\n--\n\n\n\n\n\nSean Condon\nWritten by Sean Condon\n10 followers\n·\n14 following\nNo responses yet\nHelp\n\nStatus\n\nAbout\n\nCareers\n\nPress\n\nBlog\n\nPrivacy\n\nRules\n\nTerms\n\nText to speech\n"
                }
              }
            }
          ],
          "status": "success",
          "timestamp": "2026-01-06T21:51:01.391Z",
          "resultDisplay": "",
          "displayName": "ReadFile",
          "description": "Reads and returns the content of a specified file. If the file is large, the content will be truncated. The tool's response will clearly indicate if truncation has occurred and will provide details on how to read more of the file using the 'offset' and 'limit' parameters. Handles text, images (PNG, JPG, GIF, WEBP, SVG, BMP), audio files (MP3, WAV, AIFF, AAC, OGG, FLAC), and PDF files. For text files, it can read specific line ranges.",
          "renderOutputAsMarkdown": true
        }
      ]
    },
    {
      "id": "7feaa9f7-40ed-4755-a1bc-0c20e003dd4c",
      "timestamp": "2026-01-06T21:51:19.339Z",
      "type": "gemini",
      "content": "I'll format the content into a clear Markdown structure and save it as `bmad+gemini_cli.md`.",
      "thoughts": [
        {
          "subject": "Defining the Structure",
          "description": "I'm now outlining the Markdown structure. My plan is to first define the content organization, ensuring readability. Next, I'll write the formatted content into a `.md` file, preserving all the details.",
          "timestamp": "2026-01-06T21:51:03.482Z"
        }
      ],
      "tokens": {
        "input": 14168,
        "output": 2964,
        "cached": 6556,
        "thoughts": 61,
        "tool": 0,
        "total": 17193
      },
      "model": "gemini-3-flash-preview",
      "toolCalls": [
        {
          "id": "write_file-1767736279335-0712a37c2df21",
          "name": "write_file",
          "args": {
            "file_path": "bmad+gemini_cli.md",
            "content": "# Dipping a toe cautiously in to vibe coding on the CLI with Gemini, Go and the BMAD Method\n\n**Author:** Sean Condon  \n**Date:** Sep 5, 2025  \n**Read Time:** 9 min read\n\n---\n\nMany of us engineers like to take things apart to understand what makes them tick (I’ve even learnt over many years how to put them back together too, with a minimum of parts left over!).\n\nSo when I heard the hype about vibe coding and how we could be replaced by it in a short number of years, my immediate reaction was to dive in and see how it works and if I could get it to do something useful.\n\nWhile there are many tools and techniques are cropping up to support this, such as Cursor, Replit, Lovable and Google Jules, I wanted something more fundamental and granular so that I could see the dependencies between the parts in terms more familiar. As an experienced developer I wanted to see some rigor in the process and how it deals with the many pitfalls in software development.\n\nFor some people, Vibe Coding and caution are mutually exclusive terms, and some might say what’s I’m doing here is more Spec driven development with AI — but arguing about semantics is outside of the scope of this article.\n\n## The BMAD Method\n\nA colleague suggested looking at the BMAD Method. Named after its originator, Brian Madison, this is basically an exercise in Prompt Engineering that embeds the Software Development Lifecycle in to a series of markdown documents, that contain strongly opinionated System Prompts that can be used with an LLM. BMAD has cleverly constructed personas within these prompts so that there are system prompts related to Analyst, Product Owner, Project Manager, Architect, Scrum Master, Developer and QA.\n\n## The task — create a tool\n\nRecently I’ve been looking in to Knowledge Graphs with Neo4j and specifically how they can be used to drive Context Engineering in an AI driven SRE (Site Reliability Engineering) environment. As the first step of this I wanted to create a tool that could extract relationships from Helm Charts and put them in to a Knowledge Graph.\n\nThis was vibe coding’s and BMAD method’s time to shine — could it implement this as a CLI tool in the Go programming language? While this small self-contained tool has no UI and no external service it still has enough complexity to test vibe coding’s ability to do something useful.\n\n### The prompt\n\nAs input, I came up with this initial prompt:\n\n> *plan I want to develop a new project from scratch. I want to design a service that will allow me to examine a helm chart and convert it in to cypher query commands so that is can be loaded in to Neo4j graph database. The service should accept the name of the helm chart and use the “helm template” command to produce a manifest as an intermediate step. The through this manifest “kind” in the helm chart should be taken as a node type and each instance of this kind should be treated as a node (identified by label.name and label.namespace).\n\n## Using the BMAD Method\n\nBMAD breaks up the tasks in to Planning and Execute — the former to create the document structure like the PRD and the architecture documents (which can be run on lower cost LLM models on a conventional Web UI) and the latter to generate the code (run on more code generation oriented LLM models in an IDE). The BMAD system prompts are clever enough to include checkpoints so that previous steps are not missed.\n\n## Using Google Gemini CLI\n\nI have recently become a fan of Google’s Gemini CLI and I wanted to see if I could use this to drive this vibe coding effort. I’m not inclined to switch between the latest greatest thing in LLMs and tools — I’d much prefer to choose one good one and go deep with it, as this I believe reflects what developers in a professional environment would have to do. Google Gemini 2.5 -flash and -pro models seem to be up there with the best of them, and so I wanted to stick with this for my exercise. There are many ways to consume Gemini — I went with Google AI Studio where I got an API key and linked it to a Google Cloud Platform Project.\n\nFortunately BMAD has crafted a strong Gemini related System Prompt in a `.gemini/bmad-method/GEMINI.md` that refers across to his other markdown files in `.bmad-core` folder. The npx installer for BMAD gives an option to install this, such that Gemini will pick it up properly. In essence the npx installer is not that complex and it’s only purpose is choose which files to download to the correct place.\n\n## Starting the process\n\nSo with all these ingredients in place it was time to get started. I created a new repo at `https://github.com/SRE-Spaghetti/helmgraph` on Github and then cloned it to my machine. I changed in to this directory in the terminal and there I ran `npx bmad-method install` and chose the Gemini CLI.\n\n*Screenshot of installing the BMAD method*\n\nThen I ran the `gemini --model gemini-2.5-flash` command to start the Gemini CLI and running `*help` shows that the BMAD Orchestrator is ready to go. Running this `*help` command sends the BMAD markdown files over the Gemini API and so consumes some input tokens.\n\n*Starting Gemini CLI with BMAD*\n\nThere are many different ways to start the process, and Gemini will make big assumptions that will easily steer you in the wrong direction. For instance in one case I started with `*workflow greenfield-service` and gave it the name `helmgraph` and from just that one word it created a complete project brief!\n\n*Choosing the Greenfield-Service workflow in the BMAD Method on Gemini*\n\nI found that giving it a `*plan` (with the prompt from above) beforehand produced much better results. You can always reset your context by pressing Esc, and you can track in another terminal window what have been created or changed with the `git status` command.\n\n## Creating the project brief\n\nAfter entering the plan, it churns around a lot and eventually proposes a project type — I chose `greenfield-service` and went straight to the project brief. This where we get to talk to “Mary — the business analyst” persona and we can go interactive or go wild. The interactive option provides opportunity to interject with more details — but in my case I accepted the defaults all the way through and it eventually created `docs/brief.md`.\n\nOnce saved, it automatically jumps on to “John the Project Manager” who wants to create the PRD straight away. I find this is a good place to stop (press Esc or get out of Gemini altogether) and review and edit the brief manually and commit it to Git. This gives you a baseline that you can review with others, and edit manually. Remember you’re in control, it’s only a document and you know better what it should do than AI does.\n\nIn my case I edited the brief at this stage to say I wanted it developed in Go and details about the command line options (I should have said this in the plan originally). By stopping and breaking up the task in to discrete segments that are individually understandable, we’re following Gall’s law on how to construct a complex system — something that free-flowing vibe coding tends to ignore.\n\n## Cost analysis\n\nExiting out of Gemini at this stage gives you a summary of the costs incurred:\n\n- **Input Tokens:** 2,724,275\n- **Output Tokens:** 32,406\n- **Savings Highlight:** 2,248,764 (82.5%) of input tokens were served from the cache, reducing costs.\n\nThe costs will vary over time, but as a guide in Q3 2025 the costs on the paid tier of gemini-2.5-flash were:\n- Input tokens at $0.30 per 1 million\n- Output tokens at $2.50 per 1 million.\n\n## Completing the Planning stage\n\nAfter reviewing the Product Brief you can restart Gemini and jump back into the process again with `*agent pm` and `*create-prd`. If it can’t find the product brief you can just tell it where the file is with the `@` symbol. It will generate a list of epics and ultimately a `docs/prd.md`. Again you should stop the process here, commit and review it properly.\n\nThe Planning process continues with the `*agent architect` who creates `docs/architecture.md`, and finally BMAD method required that these documents must be sharded, so that the individual Epics are extracted to separate markdown documents. Again these should be checked in to Git and reviewed.\n\n## Moving to the Execution stage\n\nThis is where BMAD suggests to move over to the more advanced model for the Scrum Master (SM) and Developer personas. Quitting Gemini and starting it again will allow choosing the model: `gemini --model gemini-2.5-pro`.\n\nThis is where the costs go up:\n- $1.25/million up to 200k input tokens and $2.50 thereafter\n- $10/million up to 200k output tokens and $15 thereafter.\n\n### The Scrum Master and Developer\n\nThe SM breaks the epics out in to stories markdown files. Again these should be checked in to Git and reviewed.\n\nThe Developer will iterate through these stories one by one, initializing a Go module and creating a `cmd/helmgraph/main.go` file. It roughly created a Go file or two per story and a unit test.\n\nI found that sometimes that Gemini running `go test …` will fail and it will try to resolve this in increasingly wacky ways. I found it’s better to stop the process (with Esc) and run the `go test ./…` myself to see what the problem was. Generally the problem was not with the test at all, but some import missing in `main.go`. I found it was useful to open the code in an IDE at the same time to see the details and run the tests.\n\nStopping the process after each story is a good practice as it allows you to check-in the created file and review it. Resuming the process works well, recognizing the steps you have already taken. If you don’t like an implementation of a story just throw it away and run the step again. I think these kind of best practices could easily be added to the BMAD system prompts — a future project…\n\n## User acceptance\n\nWhen the stories are completed, the code has to be tested in the real world, and a few edits were necessary, but even these were easily handled through Gemini CLI or Gemini Code Assist inside the IDE. For instance I used Code Assist to add the enhanced YAML parsing here and the enhanced error handling here. In the end the program ran very well and created proper syntax for Neo4j Cypher commands — even creating schema statements to constrain the Nodes.\n\n```bash\ngo run ./cmd/helmgraph/main.go -c ~/git/SRE-Spaghetti/microservices-demo/helm-chart -r foobar\n```\n\n```cypher\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:ServiceAccount) REQUIRE (n.name, n.namespace) IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:Service) REQUIRE (n.name, n.namespace) IS UNIQUE;\nCREATE CONSTRAINT IF NOT EXISTS FOR (n:Deployment) REQUIRE (n.name, n.namespace) IS UNIQUE;\nMERGE (:ServiceAccount {name: 'adservice', namespace: 'default', kind: 'ServiceAccount'});\nMERGE (:ServiceAccount {name: 'cartservice', namespace: 'default', kind: 'ServiceAccount'});\n…\nMERGE (:Service {name: 'adservice', namespace: 'default', kind: 'Service'});\nMERGE (:Service {name: 'cartservice', namespace: 'default', kind: 'Service'});\n…\nMERGE (:Deployment {name: 'adservice', namespace: 'default', kind: 'Deployment'});\nMERGE (:Deployment {name: 'cartservice', namespace: 'default', kind: 'Deployment'});\n…\nMATCH (a:Service {name: 'adservice'}), (b:Deployment {name: 'adservice'}) MERGE (a)-[:SELECTS]->(b);\nMATCH (a:Service {name: 'cartservice'}), (b:Deployment {name: 'cartservice'}) MERGE (a)-[:SELECTS]->(b);\n…\n```\n\n## Conclusion & Takeaways\n\nOverall I was happy with the vibe coding experience and that I could do it on my own terms. Technical knowledge is still very important to get a good outcome, but I think there is a huge time saving to be had here. The whole process took about half a day (including experimentation time) and I racked up costs of about €20 on tokens.\n\nI did run in to limits almost straight away on the free tier of Gemini API, so I enabled billing for my GCP project to allow more tokens be billed on demand. Having spent €20 in just one day on Gemini though makes me think I should go for Google AI Pro on Google One instead at €22/month.\n\nYou could argue the costs involved don’t justify the end result, but here I’m just touching the tip of the iceberg. I think there’s a higher cost in the long term to not be educated and proficient in these tools. The process has given me a lot of confidence in the tools, and I see a pretty strong future for vibe coding.\n\n---\n**Tags:** Gemini, Gemini Cli, Vibe Coding, Golang, SRE\n"
          },
          "result": [
            {
              "functionResponse": {
                "id": "write_file-1767736279335-0712a37c2df21",
                "name": "write_file",
                "response": {
                  "output": "Successfully created and wrote to new file: /home/amine/Documents/bmad+gemini_cli.md."
                }
              }
            }
          ],
          "status": "success",
          "timestamp": "2026-01-06T21:51:35.036Z",
          "displayName": "WriteFile",
          "description": "Writes content to a specified file in the local filesystem.\n\n      The user has the ability to modify `content`. If modified, this will be stated in the response.",
          "renderOutputAsMarkdown": true
        }
      ]
    },
    {
      "id": "cac4645b-fed3-4f6e-ae86-d69a3e9ac08d",
      "timestamp": "2026-01-06T21:51:37.748Z",
      "type": "gemini",
      "content": "I've transformed the content of `bmad+gemini_cli.txt` into a structured Markdown file at `bmad+gemini_cli.md`, using headers, lists, and code blocks for better readability while keeping the original content intact.",
      "thoughts": [
        {
          "subject": "Confirming Markdown Conversion",
          "description": "I've successfully rendered the text from `bmad+gemini_cli.txt` into `bmad+gemini_cli.md`. The transformation included structuring it with Markdown elements: headers, lists, blockquotes, and code blocks, without altering the original content. I'm ready to relay this information.",
          "timestamp": "2026-01-06T21:51:37.719Z"
        }
      ],
      "tokens": {
        "input": 17157,
        "output": 53,
        "cached": 13523,
        "thoughts": 59,
        "tool": 0,
        "total": 17269
      },
      "model": "gemini-3-flash-preview"
    },
    {
      "id": "b5598ecb-0679-4123-88e5-ef8d236909e6",
      "timestamp": "2026-01-06T21:53:40.099Z",
      "type": "error",
      "content": "MCP ERROR (context7)"
    }
  ]
}